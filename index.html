<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Particle Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f0f0f0;
            touch-action: none;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        #temperature-slider {
            position: absolute;
            right: 10px;
            top: 50px;
            width: 200px;
            transform: rotate(-90deg);
            transform-origin: left top;
        }
        #joystick {
            position: absolute;
            right: 10px;
            bottom: 10px;
            width: 160px;
            height: 160px;
            background: #ccc;
            border-radius: 50%;
            touch-action: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <script>
        // Глобальные переменные
        let particles = [];
        let epsilon = 1.0;
        let sigma = 4.0; // Диаметр частицы = 4 пикселя
        let cutoff = 2.5 * sigma;
        let dt = 0.005;
        let k_B = 1.0;
        let tau = 0.1;
        let T_target = 1.0;
        let gravity = { x: 0, y: 0 };
        let joystickDragging = false;
        let joystickPos;
        let slider;

        // Класс частицы
        class Particle {
            constructor(x, y) {
                this.pos = createVector(x, y);
                this.vel = createVector(random(-1, 1), random(-1, 1));
                this.mass = 1.0;
                this.force = createVector(0, 0);
            }
        }

        // Расчет расстояния с периодическими границами
        function distance(p1, p2) {
            let dx = p1.pos.x - p2.pos.x;
            let dy = p1.pos.y - p2.pos.y;
            dx -= 80 * Math.round(dx / 80);
            dy -= 80 * Math.round(dy / 80);
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Сила Леннард-Джонса
        function lj_force(r, epsilon, sigma) {
            if (r > cutoff || r < 0.01) return createVector(0, 0);
            let r6 = Math.pow(sigma / r, 6);
            let r12 = r6 * r6;
            let force = 24 * epsilon * (2 * r12 - r6) / r;
            return force;
        }

        // Вычисление сил
        function computeForces() {
            for (let p of particles) {
                p.force.set(0, 0);
                p.force.add(createVector(gravity.x, gravity.y));
            }
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    let p1 = particles[i];
                    let p2 = particles[j];
                    let dx = p1.pos.x - p2.pos.x;
                    let dy = p1.pos.y - p2.pos.y;
                    dx -= 80 * Math.round(dx / 80);
                    dy -= 80 * Math.round(dy / 80);
                    let r = Math.sqrt(dx * dx + dy * dy);
                    if (r < cutoff) {
                        let force = lj_force(r, epsilon, sigma);
                        let fx = force * (dx / r);
                        let fy = force * (dy / r);
                        p1.force.add(createVector(fx, fy));
                        p2.force.add(createVector(-fx, -fy));
                    }
                }
            }
        }

        // Velocity Verlet
        function velocityVerlet() {
            for (let p of particles) {
                p.vel.add(p5.Vector.mult(p.force, 0.5 * dt / p.mass));
                p.pos.add(p5.Vector.mult(p.vel, dt));
                p.pos.x = (p.pos.x + 80) % 80;
                p.pos.y = (p.pos.y + 80) % 80;
            }
            computeForces();
            for (let p of particles) {
                p.vel.add(p5.Vector.mult(p.force, 0.5 * dt / p.mass));
            }
        }

        // Термостат Berendsen
        function berendsenThermostat() {
            let T_current = computeTemperature();
            let lambda_scale = Math.sqrt(1 + (dt / tau) * (T_target / T_current - 1));
            for (let p of particles) {
                p.vel.mult(lambda_scale);
            }
        }

        // Вычисление температуры
        function computeTemperature() {
            let E_kin = 0;
            for (let p of particles) {
                E_kin += 0.5 * p.mass * p.vel.magSq();
            }
            return (2 * E_kin) / (2 * particles.length * k_B);
        }

        // p5.js setup
        function setup() {
            createCanvas(170, 250); // Увеличено для UI
            console.log("Setup: Canvas initialized");
            // Инициализация частиц
            for (let i = 0; i < 100; i++) {
                let x = random(0, 80);
                let y = random(0, 80);
                particles.push(new Particle(x, y));
            }
            console.log(`Setup: ${particles.length} particles created`);
            // Ползунок температуры
            slider = createSlider(0.1, 2.0, 1.0, 0.1);
            slider.position(140, 50);
            slider.style('width', '200px');
            slider.style('transform', 'rotate(-90deg)');
            slider.input(() => {
                T_target = slider.value();
                console.log(`Temperature set to ${T_target}`);
            });
            console.log("Setup: Slider initialized");
            // Джойстик
            joystickPos = createVector(140, 200);
            console.log("Setup: Joystick initialized at", joystickPos.x, joystickPos.y);
        }

        // p5.js draw
        function draw() {
            background(255);
            // Ограничим поле симуляции 80x80
            fill(220);
            rect(0, 0, 80, 80); // Фон поля
            velocityVerlet();
            berendsenThermostat();
            // Отрисовка частиц
            fill(0, 0, 255);
            noStroke();
            for (let p of particles) {
                ellipse(p.pos.x, p.pos.y, sigma, sigma);
            }
            // Отрисовка джойстика
            fill(200);
            ellipse(joystickPos.x, joystickPos.y, 160, 160);
            if (joystickDragging) {
                stroke(0);
                strokeWeight(2);
                let dx = mouseX - joystickPos.x;
                let dy = mouseY - joystickPos.y;
                let mag = Math.sqrt(dx * dx + dy * dy);
                if (mag > 80) {
                    dx = (dx / mag) * 80;
                    dy = (dy / mag) * 80;
                }
                line(joystickPos.x, joystickPos.y, joystickPos.x + dx, joystickPos.y + dy);
            }
            // Индикатор температуры
            fill(0);
            textSize(12);
            text(`T: ${T_target.toFixed(1)}`, 90, 20);
        }

        // Обработка тач-событий
        function touchStarted() {
            if (touches.length > 0) {
                let x = touches[0].x;
                let y = touches[0].y;
                let d = dist(x, y, joystickPos.x, joystickPos.y);
                if (d < 80) {
                    joystickDragging = true;
                    console.log(`Joystick touched at x=${x}, y=${y}`);
                    return false;
                }
                // Проверка ползунка
                let sliderX = 140;
                let sliderY = 50;
                let sliderW = 200;
                let sliderH = 20;
                if (x > sliderX && x < sliderX + sliderH && y > sliderY - sliderW && y < sliderY) {
                    console.log(`Slider touched at x=${x}, y=${y}`);
                }
            }
            return false;
        }

        function touchMoved() {
            if (joystickDragging && touches.length > 0) {
                let x = touches[0].x;
                let y = touches[0].y;
                let dx = x - joystickPos.x;
                let dy = y - joystickPos.y;
                let mag = Math.sqrt(dx * dx + dy * dy);
                if (mag > 80) {
                    dx = (dx / mag) * 80;
                    dy = (dy / mag) * 80;
                }
                gravity.x = dx * 0.1;
                gravity.y = dy * 0.1;
                console.log(`Joystick moved: gravity x=${gravity.x}, y=${gravity.y}`);
            }
            return false;
        }

        function touchEnded() {
            if (joystickDragging) {
                joystickDragging = false;
                console.log("Joystick released");
            }
            return false;
        }
    </script>
</body>
</html>
