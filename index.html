<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid and Moving Rocks Simulation</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #f0f0f0; }
        canvas { border: 1px solid #000; }
    </style>
</head>
<body>
    <canvas id="simulationCanvas" width="400" height="400"></canvas>
    <script>
        // Инициализация Telegram Web App
        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.MainButton.text = "Start Simulation";
        tg.MainButton.show();

        // Параметры симуляции
        const gridSize = 50;
        const cellSize = 8;
        const canvasSize = gridSize * cellSize;
        let grid = [];
        let rocks = [];
        let isRunning = false;
        let touchStart = null;

        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        // Инициализация сетки
        function initGrid() {
            grid = new Array(gridSize).fill().map(() => new Array(gridSize).fill());
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    let type = 'gas';
                    if (Math.random() < 0.1) type = 'liquid';
                    grid[i][j] = { type, vx: 0, vy: 0, density: type === 'liquid' ? 0.8 : 0.5, rockId: null };
                }
            }
            // Создаем 5–10 камней
            let numRocks = 5 + Math.floor(Math.random() * 6);
            for (let r = 0; r < numRocks; r++) {
                createRock();
            }
        }

        // Создание кластера камня
        function createRock() {
            let size = 5 + Math.floor(Math.random() * 11); // 5–15 ячеек
            let centerI = Math.floor(Math.random() * gridSize);
            let centerJ = Math.floor(Math.random() * gridSize);
            let rock = { cells: [], vx: 0, vy: 0, mass: 0, id: rocks.length };
            let visited = new Set();
            let queue = [[centerI, centerJ]];
            visited.add(`${centerI},${centerJ}`);
            if (grid[centerI][centerJ].type !== 'solid') {
                grid[centerI][centerJ] = { type: 'solid', vx: 0, vy: 0, density: 1, rockId: rock.id };
                rock.cells.push([centerI, centerJ]);
                rock.mass = 1;
            }

            while (rock.cells.length < size && queue.length > 0) {
                let [i, j] = queue.shift();
                let dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]].sort(() => Math.random() - 0.5);
                for (let [di, dj] of dirs) {
                    let ni = (i + di + gridSize) % gridSize;
                    let nj = (j + dj + gridSize) % gridSize;
                    if (!visited.has(`${ni},${nj}`) && grid[ni][nj].type !== 'solid') {
                        visited.add(`${ni},${nj}`);
                        queue.push([ni, nj]);
                        grid[ni][nj] = { type: 'solid', vx: 0, vy: 0, density: 1, rockId: rock.id };
                        rock.cells.push([ni, nj]);
                        rock.mass++;
                        if (rock.cells.length >= size) break;
                    }
                }
            }
            if (rock.cells.length > 0) rocks.push(rock);
        }

        // Обновление сетки
        function updateGrid() {
            let newGrid = new Array(gridSize).fill().map(() => new Array(gridSize).fill());
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    newGrid[i][j] = { type: 'gas', vx: 0, vy: 0, density: 0.1, rockId: null };
                }
            }

            // Газ и жидкость
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    let cell = grid[i][j];
                    if (cell.type === 'solid') continue;

                    let neighbors = getNeighbors(i, j);
                    let avgVx = (neighbors.reduce((sum, n) => sum + (n ? n.vx : 0), 0) + cell.vx) / (neighbors.length + 1);
                    let avgVy = (neighbors.reduce((sum, n) => sum + (n ? n.vy : 0), 0) + cell.vy) / (neighbors.length + 1);

                    if (cell.type === 'gas') {
                        newGrid[i][j].type = 'gas';
                        newGrid[i][j].vx = avgVx * 0.8;
                        newGrid[i][j].vy = avgVy * 0.8;
                        newGrid[i][j].density = Math.max(0.1, cell.density * 0.95);
                    } else if (cell.type === 'liquid') {
                        newGrid[i][j].type = 'liquid';
                        newGrid[i][j].vx = avgVx * 0.9;
                        newGrid[i][j].vy = avgVy * 0.9 + 0.1;
                        newGrid[i][j].density = Math.min(1, cell.density);
                    }

                    let newX = (i + newGrid[i][j].vx + gridSize) % gridSize;
                    let newY = (j + newGrid[i][j].vy + gridSize) % gridSize;
                    let newI = Math.floor(newX);
                    let newJ = Math.floor(newY);

                    if (grid[newI][newJ].type !== 'solid') {
                        newGrid[newI][newJ] = { ...newGrid[i][j] };
                        newGrid[i][j] = { type: 'gas', vx: 0, vy: 0, density: 0.1, rockId: null };
                    } else {
                        newGrid[i][j].vx = -newGrid[i][j].vx * 0.5;
                        newGrid[i][j].vy = -newGrid[i][j].vy * 0.5;
                    }
                }
            }

            // Камни
            for (let rock of rocks) {
                let canMove = true;
                let newCells = [];
                for (let [i, j] of rock.cells) {
                    let newX = (i + rock.vx + gridSize) % gridSize;
                    let newY = (j + rock.vy + gridSize) % gridSize;
                    let newI = Math.floor(newX);
                    let newJ = Math.floor(newY);
                    if (grid[newI][newJ].type === 'solid' && grid[newI][newJ].rockId !== rock.id) {
                        canMove = false;
                        break;
                    }
                    newCells.push([newI, newJ]);
                }

                if (canMove) {
                    rock.cells = newCells;
                    for (let [i, j] of rock.cells) {
                        newGrid[i][j] = { type: 'solid', vx: rock.vx, vy: rock.vy, density: 1, rockId: rock.id };
                    }
                    rock.vx *= 0.95;
                    rock.vy *= 0.95;
                } else {
                    rock.vx = -rock.vx * 0.5;
                    rock.vy = -rock.vy * 0.5;
                    for (let [i, j] of rock.cells) {
                        newGrid[i][j] = { type: 'solid', vx: rock.vx, vy: rock.vy, density: 1, rockId: rock.id };
                    }
                }
            }

            grid = newGrid;
        }

        // Получение соседей
        function getNeighbors(i, j) {
            let neighbors = [];
            const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (let [di, dj] of dirs) {
                let ni = (i + di + gridSize) % gridSize;
                let nj = (j + dj + gridSize) % gridSize;
                if (grid[ni][nj].type !== 'solid') {
                    neighbors.push(grid[ni][nj]);
                }
            }
            return neighbors;
        }

        // Отрисовка сетки
        function drawGrid() {
            ctx.clearRect(0, 0, canvasSize, canvasSize);
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    let cell = grid[i][j];
                    if (cell.type === 'gas') {
                        ctx.fillStyle = `rgba(100, 150, 255, ${cell.density})`;
                    } else if (cell.type === 'liquid') {
                        ctx.fillStyle = `rgba(0, 50, 150, ${cell.density})`;
                    } else if (cell.type === 'solid') {
                        let shade = 90 + Math.random() * 20;
                        ctx.fillStyle = `rgba(${shade}, ${shade}, ${shade}, 1)`;
                    }
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
        }

        // Обработка свайпа
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!touchStart) return;
            let touchEnd = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            let dx = (touchEnd.x - touchStart.x) / canvasSize * 5;
            let dy = (touchEnd.y - touchStart.y) / canvasSize * 5;
            applyForce(touchStart.x, touchStart.y, dx, dy);
            touchStart = null;
        });

        function applyForce(x, y, dx, dy) {
            let i = Math.floor(x / cellSize);
            let j = Math.floor(y / cellSize);
            if (i >= 0 && i < gridSize && j >= 0 && j < gridSize) {
                let cell = grid[i][j];
                if (cell.type === 'solid') {
                    let rock = rocks[cell.rockId];
                    rock.vx += dx / rock.mass;
                    rock.vy += dy / rock.mass;
                } else {
                    grid[i][j].vx += dx;
                    grid[i][j].vy += dy;
                    grid[i][j].density = Math.min(1, grid[i][j].density + 0.2);
                }
            }
        }

        // Основной цикл
        function loop() {
            if (isRunning) {
                updateGrid();
            }
            drawGrid(); // Всегда отрисовываем
            requestAnimationFrame(loop);
        }

        // Инициализация и запуск
        try {
            initGrid();
            drawGrid();
            loop();
        } catch (e) {
            console.error('Initialization error:', e);
        }

        // Обработка кнопки Telegram
        tg.MainButton.onClick(() => {
            isRunning = !isRunning;
            tg.MainButton.text = isRunning ? "Stop Simulation" : "Start Simulation";
        });
    </script>
</body>
</html>
