<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #fff;
        }
        #temperature-slider {
            position: absolute;
            right: 10px;
            top: 10px;
            height: 60px;
        }
        #joystick {
            position: absolute;
            right: 10px;
            bottom: 10px;
            width: 60px;
            height: 60px;
            background: #ccc;
            border-radius: 50%;
            touch-action: none;
        }
    </style>
</head>
<body>
    <script>
        // Telegram Web App
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();
        function applyTelegramTheme() {
            let theme = window.Telegram.WebApp.themeParams;
            document.body.style.backgroundColor = theme.bg_color || '#ffffff';
        }
        applyTelegramTheme();

        // Глобальные переменные
        let particles = [];
        let epsilon = 1.0;
        let sigma = 4.0; // Диаметр частицы = 4 пикселя
        let cutoff = 2.5 * sigma;
        let dt = 0.005;
        let k_B = 1.0;
        let tau = 0.1;
        let T_target = 1.0;
        let gravity = { x: 0, y: 0 };
        let joystickDragging = false;
        let joystickPos;

        // Класс частицы
        class Particle {
            constructor(x, y) {
                this.pos = createVector(x, y);
                this.vel = createVector(random(-1, 1), random(-1, 1));
                this.mass = 1.0;
                this.force = createVector(0, 0);
            }
        }

        // Расчет расстояния с периодическими границами
        function distance(p1, p2) {
            let dx = p1.pos.x - p2.pos.x;
            let dy = p1.pos.y - p2.pos.y;
            dx -= 80 * Math.round(dx / 80);
            dy -= 80 * Math.round(dy / 80);
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Сила Леннард-Джонса
        function lj_force(r, epsilon, sigma) {
            if (r > cutoff || r < 0.01) return createVector(0, 0);
            let r6 = Math.pow(sigma / r, 6);
            let r12 = r6 * r6;
            let force = 24 * epsilon * (2 * r12 - r6) / r;
            return force;
        }

        // Вычисление сил
        function computeForces() {
            for (let p of particles) {
                p.force.set(0, 0);
                p.force.add(createVector(gravity.x, gravity.y));
            }
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    let p1 = particles[i];
                    let p2 = particles[j];
                    let dx = p1.pos.x - p2.pos.x;
                    let dy = p1.pos.y - p2.pos.y;
                    dx -= 80 * Math.round(dx / 80);
                    dy -= 80 * Math.round(dy / 80);
                    let r = Math.sqrt(dx * dx + dy * dy);
                    if (r < cutoff) {
                        let force = lj_force(r, epsilon, sigma);
                        let fx = force * (dx / r);
                        let fy = force * (dy / r);
                        p1.force.add(createVector(fx, fy));
                        p2.force.add(createVector(-fx, -fy));
                    }
                }
            }
        }

        // Velocity Verlet
        function velocityVerlet() {
            for (let p of particles) {
                p.vel.add(p5.Vector.mult(p.force, 0.5 * dt / p.mass));
                p.pos.add(p5.Vector.mult(p.vel, dt));
                p.pos.x = (p.pos.x + 80) % 80;
                p.pos.y = (p.pos.y + 80) % 80;
            }
            computeForces();
            for (let p of particles) {
                p.vel.add(p5.Vector.mult(p.force, 0.5 * dt / p.mass));
            }
        }

        // Термостат Berendsen
        function berendsenThermostat() {
            let T_current = computeTemperature();
            let lambda_scale = Math.sqrt(1 + (dt / tau) * (T_target / T_current - 1));
            for (let p of particles) {
                p.vel.mult(lambda_scale);
            }
        }

        // Вычисление температуры
        function computeTemperature() {
            let E_kin = 0;
            for (let p of particles) {
                E_kin += 0.5 * p.mass * p.vel.magSq();
            }
            return (2 * E_kin) / (2 * particles.length * k_B);
        }

        // p5.js setup
        function setup() {
            createCanvas(100, 80);
            for (let i = 0; i < 100; i++) {
                let x = random(0, 80);
                let y = random(0, 80);
                particles.push(new Particle(x, y));
            }
            let slider = createSlider(0.1, 2.0, 1.0, 0.1);
            slider.position(85, 10);
            slider.style('height', '60px');
            slider.input(() => {
                T_target = slider.value();
            });
            joystickPos = createVector(90, 70);
        }

        // p5.js draw
        function draw() {
            background(255);
            velocityVerlet();
            berendsenThermostat();
            fill(0, 0, 255);
            noStroke();
            for (let p of particles) {
                ellipse(p.pos.x, p.pos.y, sigma, sigma);
            }
            fill(200);
            ellipse(joystickPos.x, joystickPos.y, 20, 20);
            if (joystickDragging) {
                stroke(0);
                line(joystickPos.x, joystickPos.y, mouseX, mouseY);
            }
        }

        // Джойстик
        function touchStarted() {
            let d = dist(mouseX, mouseY, joystickPos.x, joystickPos.y);
            if (d < 10) {
                joystickDragging = true;
            }
            return false;
        }

        function touchMoved() {
            if (joystickDragging) {
                let dx = mouseX - joystickPos.x;
                let dy = mouseY - joystickPos.y;
                let mag = Math.sqrt(dx * dx + dy * dy);
                if (mag > 10) {
                    dx = (dx / mag) * 10;
                    dy = (dy / mag) * 10;
                }
                gravity.x = dx * 0.1;
                gravity.y = dy * 0.1;
            }
            return false;
        }

        function touchEnded() {
            joystickDragging = false;
            return false;
        }
    </script>
</body>
</html>
