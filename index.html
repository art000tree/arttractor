<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Particle Simulator</title>
    <style>
        body {
            margin: 0;
            background: black;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #canvas {
            border: 1px solid white;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
        }
        #temp-slider {
            position: absolute;
            right: 10px;
            top: 50px;
            height: 500px;
            writing-mode: bt-lr;
            transform: rotate(180deg);
        }
        #joystick {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            touch-action: none;
        }
        #joystick-pointer {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            transform: translate(-50%, -50%);
        }
        input, button {
            background: #333;
            color: white;
            border: 1px solid white;
            padding: 5px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="300" height="600"></canvas>
    <div id="controls">
        <div>
            <label>Particles: <input id="particle-count" type="number" value="500" min="1" max="1000"></label>
            <button id="apply-particles">Apply</button>
        </div>
        <div>
            <label>Gravity: <input id="gravity-mag" type="number" value="1" min="0" step="0.1"></label>
            <button id="apply-gravity">Apply</button>
        </div>
    </div>
    <input id="temp-slider" type="range" min="0" max="100" value="100" orient="vertical">
    <div id="joystick">
        <div id="joystick-pointer" style="left: 40px; top: 40px;"></div>
    </div>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        // Telegram Web App integration
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const particleCountInput = document.getElementById('particle-count');
        const applyParticlesBtn = document.getElementById('apply-particles');
        const gravityMagInput = document.getElementById('gravity-mag');
        const applyGravityBtn = document.getElementById('apply-gravity');
        const tempSlider = document.getElementById('temp-slider');
        const joystick = document.getElementById('joystick');
        const joystickPointer = document.getElementById('joystick-pointer');

        let particles = [];
        let gravity = { x: 0, y: 1, mag: 1 };
        let temperature = 100;

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.radius = 2; // Diameter 4 pixels
                this.bonds = [];
            }
        }

        function initParticles(count) {
            particles = [];
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                ));
            }
        }

        function updatePhysics() {
            const dt = 0.016; // ~60 FPS
            const bondForce = 0.5; // Constant bond force

            // Update velocities based on temperature
            const tempScale = temperature / 100;
            particles.forEach(p => {
                p.vx += (Math.random() - 0.5) * 0.1 * tempScale;
                p.vy += (Math.random() - 0.5) * 0.1 * tempScale;
            });

            // Clear old bonds
            particles.forEach(p => p.bonds = []);

            // Check bonds and collisions
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = 4; // Stable bond distance
                    const maxDist = 6; // Bond break distance

                    if (dist < minDist) {
                        // Repulsion (collision)
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const impulse = bondForce * overlap;
                        p1.vx += nx * impulse * dt;
                        p1.vy += ny * impulse * dt;
                        p2.vx -= nx * impulse * dt;
                        p2.vy -= ny * impulse * dt;
                        p1.bonds.push(p2);
                        p2.bonds.push(p1);
                    } else if (dist <= maxDist) {
                        // Attraction to 4 pixels
                        p1.bonds.push(p2);
                        p2.bonds.push(p1);
                        const force = bondForce * (dist - minDist);
                        const nx = dx / dist;
                        const ny = dy / dist;
                        p1.vx -= nx * force * dt;
                        p1.vy -= ny * force * dt;
                        p2.vx += nx * force * dt;
                        p2.vy += ny * force * dt;
                    }
                }
            }

            // Apply gravity and update positions
            particles.forEach(p => {
                p.vx += gravity.x * gravity.mag * dt;
                p.vy += gravity.y * gravity.mag * dt;
                p.x += p.vx * dt * 60;
                p.y += p.vy * dt * 60;

                // Wall collisions
                if (p.x < p.radius) {
                    p.x = p.radius;
                    p.vx = Math.abs(p.vx);
                } else if (p.x > canvas.width - p.radius) {
                    p.x = canvas.width - p.radius;
                    p.vx = -Math.abs(p.vx);
                }
                if (p.y < p.radius) {
                    p.y = p.radius;
                    p.vy = Math.abs(p.vy);
                } else if (p.y > canvas.height - p.radius) {
                    p.y = canvas.height - p.radius;
                    p.vy = -Math.abs(p.vy);
                }
            });
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bonds
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            particles.forEach(p => {
                p.bonds.forEach(b => {
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                });
            });

            // Draw particles
            ctx.fillStyle = 'blue';
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function loop() {
            updatePhysics();
            draw();
            requestAnimationFrame(loop);
        }

        // Initialize
        initParticles(500);
        loop();

        // Event listeners
        applyParticlesBtn.addEventListener('click', () => {
            let count = parseInt(particleCountInput.value);
            if (count < 1) count = 1;
            if (count > 1000) count = 1000;
            initParticles(count);
        });

        applyGravityBtn.addEventListener('click', () => {
            gravity.mag = parseFloat(gravityMagInput.value) || 0;
        });

        tempSlider.addEventListener('input', () => {
            temperature = parseInt(tempSlider.value);
        });

        // Joystick
        let joystickActive = false;
        joystick.addEventListener('touchstart', e => {
            joystickActive = true;
            handleJoystick(e);
        });
        joystick.addEventListener('touchmove', handleJoystick);
        joystick.addEventListener('touchend', () => {
            joystickActive = false;
            joystickPointer.style.left = '40px';
            joystickPointer.style.top = '40px';
            gravity.x = 0;
            gravity.y = 1;
        });

        function handleJoystick(e) {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + 40;
            const centerY = rect.top + 40;
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = 30;
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }
            joystickPointer.style.left = 40 + dx + 'px';
            joystickPointer.style.top = 40 + dy + 'px';
            gravity.x = dx / maxDist;
            gravity.y = dy / maxDist;
        }
    </script>
</body>
</html>
